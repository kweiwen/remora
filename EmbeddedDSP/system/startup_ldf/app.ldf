/*
** ADSP-21479 linker description file generated on Aug 09, 2021 at 11:38:02.
*/
/*
** Copyright (C) 2000-2020 Analog Devices Inc., All Rights Reserved.
**
** This file is generated automatically based upon the options selected
** in the System Configuration utility. Changes to the LDF configuration
** should be made by modifying the appropriate options rather than editing
** this file. To access the System Configuration utility, double-click the
** system.svc file from a navigation view.
**
** Custom additions can be inserted within the user-modifiable sections,
** these are bounded by comments that start with "$VDSG". Only changes
** placed within these sections are preserved when this file is re-generated.
**
** Product      : CrossCore Embedded Studio
** Tool Version : 6.2.1.6
*/

ARCHITECTURE(ADSP-21479)

/*
** Define a linked library list.
*/
$LIBRARIES = 
    libcc.dlb
   ,libc.dlb
   ,libio.dlb
   ,libcpp.dlb
   ,libosal_noos.dlb
   ,libprofile.dlb
   ,libssl.dlb
   ,libdsp.dlb
   ,libdyn.dlb
   ;

/*
** Define a linked objects list.
*/
$OBJECTS = 
    "app_startup.doj"
   ,$COMMAND_LINE_OBJECTS
   ;

/*
** List of all objects and libraries.
*/
$OBJS_LIBS = $OBJECTS, $LIBRARIES;

/*
** List of objects and libraries which prefer internal memory as
** specified by prefersMem attribute.
*/
$OBJS_LIBS_INTERNAL = 
    $OBJS_LIBS{prefersMem("internal")}
   ;

/*
** List of objects and libraries which don't have a preference for
** external memory as specified by prefersMem attribute.
*/
$OBJS_LIBS_NOT_EXTERNAL = 
    $OBJS_LIBS{!prefersMem("external")}
   ;

#define ASYNC_MEMTYPE DM RAM


MEMORY
{
   /* ADSP-21479 MEMORY MAP.
   **
   ** The SHARC 21479 has 5Mbit RAM and 4Mbit ROM in total.
   **
   ** -------------------------- BLOCK 0 ---------------------------------------
   ** 0x0008 C000 to 0x0009 3FFF  Normal word (48) Space (1.5 Mbit RAM)
   ** 0x0009 2000 to 0x0009 DFFF  Normal word (32) Space (1.5 Mbit RAM)
   ** 0x0012 4000 to 0x0013 BFFF  Short word  (16) Space (1.5 Mbit RAM)
   **
   ** Notes:
   ** 1) The interrupt Vector Table (IVT) code is placed in internal memory
   **    by default and has to use ISA (NW, 48 bit) instructions.
   ** 2) The loader kernel uses 256 ISA instructions from the start of the 
   **    IVT. The final action it does is to load the application code to these
   **    address overwriting it's own code. The application code in these
   **    addresses therefore must also be ISA instructions. Do not put 
   **    VISA (SW) instructions in these 256 locations.
   */
   mem_iv_code             { TYPE(PM RAM) START(0x0008C000) END(0x0008C0A7) WIDTH(48) }
   mem_block0_nwco         { TYPE(PM RAM) START(0x0008C0A8) END(0x0008C0FF) WIDTH(48) }
   mem_block0_sw16         { TYPE(SW RAM) START(0x00124300) END(0x0013BFFF) WIDTH(16) }

   /*
   ** -------------------------- BLOCK 1 ---------------------------------------
   ** 0x000A C000 to 0x000B 3FFF  Normal word (48) Space (1.5 Mbit RAM)
   ** 0x000B 2000 to 0x000B DFFF  Normal word (32) Space (1.5 Mbit RAM)
   ** 0x0016 4000 to 0x0017 BFFF  Short word (16)  Space (1.5 Mbit RAM)
   */
   mem_block1_dm32         { TYPE(DM RAM) START(0x000B2000) END(0x000BDFFF) WIDTH(32) }

   /*
   ** -------------------------- BLOCK 2 ---------------------------------------
   ** 0x000C 0000 to 0x000C 5554  Normal word (48) Space (1 Mbit RAM)
   ** 0x000C 0000 to 0x000C 7FFF  Normal word (32) Space (1 Mbit RAM)
   ** 0x0018 0000 to 0x0018 FFFF  Short word (16) Space (1 Mbit RAM)
   */
   mem_block2_pm32         { TYPE(PM RAM) START(0x000C0000) END(0x000C7FFF) WIDTH(32) }

   /*
   ** -------------------------- BLOCK 3 ---------------------------------------
   ** 0x000E 0000 to 0x000E 5554  Normal word (48) Space (1 Mbit RAM)
   ** 0x000E 0000 to 0x000E 7FFF  Normal word (32) Space (1 Mbit RAM)
   ** 0x001C 0000 to 0x001C FFFF  Short word (16)  Space (1 Mbit RAM)
   */
   mem_block3_dm32         { TYPE(DM RAM) START(0x000E0000) END(0x000E7FFF) WIDTH(32) }

   /*
   ** ------------------------- External memory --------------------------------
   ** This LDF defines the memory configuration for the 256Mb/32MB SDRAM
   ** on the ADSP-21479 EZ-Board.
   **
   ** 0x0020 0000 0x009F FFFF SDRAM (bank 0)
   ** 0x0400 0000 0x043F FFFF Flash memory (bank 1)
   ** 0x0C00 0000 0x0C0F FFFF SRAM for 16-bit address space (bank 3)
   ** 0x0C00 0000 0x0C07 FFFF SRAM for 32-bit address space (bank 3)
   **
   ** See "ADSP-21479 EZ-Board Evaluation System Manual" for further details.
   **
   ** Notes:
   ** 1) Instruction execution is only supported from bank 0 (SDRAM here)
   ** in the following memory range:
   **   - For VISA code (i.e 16bit accesses)     : 0x00600000 - 0x00FFFFFF
   **   - For NonVISA code (i.e 48 bit accesses) : 0x00200000 - 0x005FFFFF
   ** 2) Memory locations 0x5FFFFD-0x5FFFFF (NW) and 0x600000-0x600008 (SW)
   ** are not used for instructions as required by "ADSP-214xx SHARC Processor
   ** Hardware Reference" revision 1.0 pages 4-45 and 4-46.
   */
   mem_sdram_swco          { TYPE(SW RAM SYNCHRONOUS) START(0x00600009) END(0x0065FFFF) WIDTH(16) }
   mem_sdram_nwco          { TYPE(PM RAM SYNCHRONOUS) START(0x00220000) END(0x0043FFFF) WIDTH(16) }
   mem_sdram_dmda          { TYPE(DM RAM SYNCHRONOUS) START(0x00660000) END(0x008FFFFF) WIDTH(16) }
   mem_sdram_pmda          { TYPE(DM RAM SYNCHRONOUS) START(0x00900000) END(0x009FFFFF) WIDTH(16) }
   mem_sram                { TYPE(DM RAM ASYNCHRONOUS) START(0x0C000000) END(0x0C07FFFF) WIDTH(16) }
   mem_flash               { TYPE(DM RAM ASYNCHRONOUS) START(0x04000000) END(0x043FFFFF) WIDTH(8) }
} /* MEMORY */

PROCESSOR p0
{
   OUTPUT($COMMAND_LINE_OUTPUT_FILE)
   KEEP(_main)
   KEEP(___ctor_NULL_marker)
   SECTIONS
   {
      #define IV_CODE dxe_iv_code
      IV_CODE PM
      {
         INPUT_SECTIONS( $OBJECTS(iv_code) )
      } > mem_iv_code
      
      dxe_block0_nw_code PM
      {
         INPUT_SECTIONS( $OBJS_LIBS(seg_int_code seg_init) )
         INPUT_SECTIONS( $OBJS_LIBS(seg_pmco) )
      } > mem_block0_nwco
      
      dxe_block0_sw_code_prio0 SW
      {
         FILL(0x1) /* fill in gaps in the memory with NOPs */
         INPUT_SECTIONS( $OBJS_LIBS(seg_int_code_sw seg_int_code) )
      } > mem_block0_sw16
      
      dxe_block0_nw_code_prio0 PM
      {
         INPUT_SECTIONS( $OBJS_LIBS(seg_int_code) )
         INPUT_SECTIONS( $OBJS_LIBS(seg_init) )
      } > mem_block0_sw16
      
      dxe_block0_sw_code_prio1 SW
      {
         FILL(0x1) /* fill in gaps in the memory with NOPs */
         INPUT_SECTIONS( $OBJS_LIBS_INTERNAL(seg_swco seg_pmco) )
      } > mem_block0_sw16
      
      dxe_block0_nw_code_prio1 PM
      {
         INPUT_SECTIONS( $OBJS_LIBS_INTERNAL( seg_pmco ) )
      } > mem_block0_sw16
      
      dxe_block0_sw_code_prio2 SW
      {
         FILL(0x1) /* fill in gaps in the memory with NOPs */
         INPUT_SECTIONS( $OBJS_LIBS_NOT_EXTERNAL(seg_swco seg_pmco) )
         INPUT_SECTIONS( $OBJS_LIBS(seg_swco seg_pmco) )
      } > mem_block0_sw16
      
      #define BLOCK0_SW_CODE dxe_block0_sw_code_prio3
      BLOCK0_SW_CODE SW
      {
         FILL(0x1) /* fill in gaps in the memory with NOPs */
         INPUT_SECTIONS( $OBJS_LIBS(seg_swco seg_pmco) )
      } > mem_block0_sw16
      
      #define BLOCK0_NW_CODE dxe_block0_nw_code_prio3
      BLOCK0_NW_CODE PM
      {
         INPUT_SECTIONS( $OBJS_LIBS(seg_pmco) )
      } > mem_block0_sw16
      
      dxe_block2_pm_data
      {
         INPUT_SECTIONS( $OBJS_LIBS_INTERNAL(seg_pmda) )
         INPUT_SECTIONS( $OBJS_LIBS_NOT_EXTERNAL(seg_pmda) )
         INPUT_SECTIONS( $OBJS_LIBS(seg_pmda) )
      } > mem_block2_pm32
      
      dxe_block1_dm_data_prio0
      {
         RESERVE(heaps_and_system_stack_in_Internal, heaps_and_system_stack_in_Internal_length = 2048, 2)
         INPUT_SECTIONS( $OBJS_LIBS(seg_int_data) )
      } > mem_block1_dm32
      
      dxe_block1_dm_data_prio1
      {
         INPUT_SECTIONS( $OBJS_LIBS_INTERNAL(seg_dmda seg_vtbl) )
      } > mem_block1_dm32
      
      dxe_block1_bsz_prio1 ZERO_INIT
      {
         INPUT_SECTIONS( $OBJS_LIBS_INTERNAL(.bss) )
      } > mem_block1_dm32
      
      dxe_block1_dm_data_prio2
      {
         INPUT_SECTIONS( $OBJS_LIBS_NOT_EXTERNAL(seg_dmda seg_vtbl) )
      } > mem_block1_dm32
      
      dxe_block1_bsz_prio2 ZERO_INIT
      {
         INPUT_SECTIONS( $OBJS_LIBS_NOT_EXTERNAL(.bss) )
      } > mem_block1_dm32
      
      dxe_block1_dm_data_prio3
      {
         INPUT_SECTIONS( $OBJS_LIBS(seg_dmda seg_vtbl) )
      } > mem_block1_dm32
      
      dxe_block1_bsz_prio3 ZERO_INIT
      {
         INPUT_SECTIONS( $OBJS_LIBS(.bss) )
      } > mem_block1_dm32
      
      dxe_block3_dm_data_prio0
      {
         RESERVE(heaps_and_system_heap_in_Internal, heaps_and_system_heap_in_Internal_length = 2048, 2)
         INPUT_SECTIONS( $OBJS_LIBS(seg_int_data) )
      } > mem_block3_dm32
      
      dxe_block3_dm_data_prio1
      {
         INPUT_SECTIONS( $OBJS_LIBS_INTERNAL(seg_dmda seg_vtbl) )
      } > mem_block3_dm32
      
      dxe_block3_bsz_prio1 ZERO_INIT
      {
         INPUT_SECTIONS( $OBJS_LIBS_INTERNAL(.bss) )
      } > mem_block3_dm32
      
      dxe_block3_dm_data_prio2
      {
         INPUT_SECTIONS( $OBJS_LIBS_NOT_EXTERNAL(seg_dmda seg_vtbl) )
      } > mem_block3_dm32
      
      dxe_block3_bsz_prio2 ZERO_INIT
      {
         INPUT_SECTIONS( $OBJS_LIBS_NOT_EXTERNAL(.bss) )
      } > mem_block3_dm32
      
      dxe_block3_dm_data_prio3
      {
         INPUT_SECTIONS( $OBJS_LIBS(seg_dmda seg_vtbl) )
      } > mem_block3_dm32
      
      dxe_block3_bsz_prio3 ZERO_INIT
      {
         INPUT_SECTIONS( $OBJS_LIBS(.bss) )
      } > mem_block3_dm32
      
      dxe_block3_overflow_data
      {
         /* Use any unused memory in the dm data designated blocks 1 and 3
         ** for pm data if we've not been able to map it to block 2.
         */
         INPUT_SECTIONS( $OBJS_LIBS(seg_pmda) )
      } > mem_block3_dm32
      
      dxe_block3_heap NO_INIT
      {
         RESERVE_EXPAND(heaps_and_system_heap_in_Internal, heaps_and_system_heap_in_Internal_length, 0, 2)
         ldf_heap_space = heaps_and_system_heap_in_Internal;
         ldf_heap_end = (ldf_heap_space + (heaps_and_system_heap_in_Internal_length - 2)) & 0xfffffffe;
         ldf_heap_length = ldf_heap_end - ldf_heap_space;
      } > mem_block3_dm32
      
      dxe_block1_overflow_data
      {
         /* Use any unused memory in the dm data designated blocks 1 and 3
         ** for pm data if we've not been able to map it to block 2.
         */
         INPUT_SECTIONS( $OBJS_LIBS(seg_pmda) )
      } > mem_block1_dm32
      
      dxe_block1_stack NO_INIT
      {
         RESERVE_EXPAND(heaps_and_system_stack_in_Internal, heaps_and_system_stack_in_Internal_length, 0, 2)
         ldf_stack_space = heaps_and_system_stack_in_Internal;
         ldf_stack_end = (ldf_stack_space + (heaps_and_system_stack_in_Internal_length - 2)) & 0xfffffffe;
         ldf_stack_length = ldf_stack_end - ldf_stack_space;
      } > mem_block1_dm32
      
      dxe_block2_overflow_data
      {
         // Use any unused memory in the pm data designated block 2 for
         // dm data if we've not been able to map it to the dm data blocks
         // 1 and 3.
         INPUT_SECTIONS( $OBJS_LIBS(seg_int_data seg_dmda seg_vtbl) )
      } > mem_block2_pm32
      
      dxe_block2_bsz ZERO_INIT
      {
         INPUT_SECTIONS( $OBJS_LIBS(.bss) )
      } > mem_block2_pm32
      
      dxe_sdram_sw_code SW
      {
         FILL(0x1) /* fill in gaps in the memory with NOPs */
         INPUT_SECTIONS( $OBJS_LIBS(seg_ext_code seg_swco seg_pmco) )
      } > mem_sdram_swco
      
      dxe_sdram_nw_code PM
      {
         INPUT_SECTIONS( $OBJS_LIBS(seg_ext_code seg_pmco) )
      } > mem_sdram_nwco
      
      dxe_sdram_pm_data
      {
         INPUT_SECTIONS( $OBJS_LIBS(seg_ext_pmda seg_pmda) )
      } > mem_sdram_pmda
      
      dxe_sdram_user_tables
      {
         FORCE_CONTIGUITY
      } > mem_sdram_dmda
      
      dxe_sdram_cpp_ctors
      {
         FORCE_CONTIGUITY
         __ctors = .;    /* points to the start of the section */
         INPUT_SECTIONS( $OBJS_LIBS(seg_ctdm) )
         INPUT_SECTIONS( $OBJS_LIBS(seg_ctdml) )
      } > mem_sdram_dmda
      
      dxe_sdram_data
      {
         RESERVE(heaps_and_stack_in_External, heaps_and_stack_in_External_length = 540000, 2)
         INPUT_SECTIONS( $OBJS_LIBS(seg_ext_data seg_sdram seg_dmda seg_vtbl) )
      } > mem_sdram_dmda
      
      dxe_sdram_bsz ZERO_INIT
      {
         INPUT_SECTIONS( $OBJS_LIBS(.bss) )
      } > mem_sdram_dmda
      
      dxe_sdram_stack_and_heap NO_INIT
      {
         RESERVE_EXPAND(heaps_and_stack_in_External, heaps_and_stack_in_External_length, 0, 2)
         delay_heap_space = heaps_and_stack_in_External;
         delay_heap_end = (delay_heap_space + (270000 - 2)) & 0xfffffffe;
         delay_heap_length = delay_heap_end - delay_heap_space;
         reverse_delay_heap_space = delay_heap_space + delay_heap_length + 2;
         reverse_delay_heap_end = (reverse_delay_heap_space + (270000 - 2)) & 0xfffffffe;
         reverse_delay_heap_length = reverse_delay_heap_end - reverse_delay_heap_space;
      } > mem_sdram_dmda
      
      dxe_flash
      {
         INPUT_SECTIONS( $OBJS_LIBS(seg_flash) )
      } > mem_flash
      
      dxe_sram
      {
         INPUT_SECTIONS( $OBJS_LIBS(seg_sram) )
      } > mem_sram
      
   } /* SECTIONS */
} /* p0 */

